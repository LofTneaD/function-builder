# Парсер и вычислитель математических выражений

## Краткий обзор
Проект представляет собой парсер и вычислитель математических выражений с поддержкой аргумента `x`, отображением результатов в консоли и в WPF-интерфейсе. Основные части:

- `FunctionBuilder.Logic` — ядро: парсер в обратную польскую нотацию и вычислитель.
- `FunctionBuilder.Console` — минимальный пример CLI-приложения.
- `FunctionBuilder.WPF` — простая WPF-UI для ввода выражения и отображения результата.
- `FunctionBuilder.Tests` — тесты на `NUnit`.

## Использованные принципы ООП
- Инкапсуляция: логика парсинга и вычисления отделена в классы `ReversePolishNotation` и `Function`. Взаимодействие с внутренними данными происходит через публичные методы (`Parse`, `CalculateFunctionValues`).
- Абстракция: абстрактный класс `Operation` скрывает детали конкретных операций, предоставляя единый интерфейс `Evaluate`.
- Наследование и полиморфизм: конкретные операции (`Plus`, `Minus`, `Multiply`, `Devide`, `Log`) наследуют `Operation` и реализуют `Evaluate`. Это позволяет в рантайме работать с операцией через базовый тип.
- Разделение ответственности (SRP): 
  - `ReversePolishNotation` отвечает за парсинг и преобразование в RPN.
  - `Function` — отвечает за подготовку и вычисление значений функции.
  - UI-проекты — только за отображение и ввод.

## Использованные архитектурные идеи и паттерны
- Простая фабрика/фабричный метод (неформально): метод `ReadOperationOrArgument` в `ReversePolishNotation` выступает как небольшой фабричный блок, создающий объекты типа `Operation`/`Argument` по строковому токену.
- Стратегия / Полиморфный вызов: каждая операция реализует `Evaluate` — это по сути стратегия вычисления для данного оператора.
- Interpreter / выражение: проект архитектурно напоминает реализацию интерпретатора выражений: входная строка токенизируется, строится RPN, затем RPN интерпретируется/вычисляется.
- Разделение логики и представления: наличие отдельных проектов для `Logic`, `Console` и `WPF` демонстрирует простую многослойную организацию.

## Ключевые классы и их ответственность
- `ReversePolishNotation` — токенизация строки, распознавание чисел, операций и скобок, построение обратной польской нотации.
- `Function` — хранит RPN, вычисляет значение выражения для конкретного `x` или диапазона значений.
- `Operation` (и наследники) — инкапсулируют реализацию операций (`+`, `-`, `*`, `/`, `log`).
- `Argument` — представляет переменную `x`.
- `FunctionValue` — простая DTO для биндинга в UI (X/Y).

## Тестирование
- В проекте `FunctionBuilder.Tests` есть тесты на `NUnit`, которые проверяют корректность парсинга RPN и вычислений. Это показывает умение писать модульные тесты и базовую уверенность в поддержке качества кода.

## Что это хорошо показывает о кандидатуре джуниора
- Понимание базовых ООП-концепций (наследование, полиморфизм, инкапсуляция).
- Умение разбивать задачу по классам и выделять зоны ответственности.
- Знание простых паттернов (фабричный подход, стратегия/полиморфизм).
- Умение писать базовые модульные тесты и подключать несколько проектов (логика + UI + тесты).
- Практический опыт работы с .NET и WPF (на уровне простого UI).

## Рекомендации по улучшению (коротко, как темы для дальнейшего развития)
- Интерфейсы: вынести `Operation` в интерфейс `IOperation` для более явной инверсии зависимостей.
- Регистрация операций: заменить `switch` в `ReadOperationOrArgument` на конфигурируемную реестровую фабрику (сложнее, но масштабируемо).
- Именование: исправить опечатки (`Devide` → `Divide`) и добавить XML-комментарии для публичных API.
- Обработка ошибок: использовать специализированные исключения и более дружелюбные сообщения; обрабатывать деление на ноль.
- Тесты: добавить позитивные и негативные кейсы, пограничные значения, тесты для парсера скобок и некорректных выражений.
- Архитектура: рассмотреть выделение слоя токенизации отдельно от построения RPN.

## Краткая инструкция, как рассказать это на интервью
- Опишите задачу проекта и результат (что делает).
- Покажите `FunctionBuilder.Logic` — объясните разбиение на `ReversePolishNotation` и `Function`.
- Подчеркните `Operation`/наследники как пример применения полиморфизма и стратегии.
- Упомяните тесты в `FunctionBuilder.Tests` как признак заботы о качестве.
- Закончите списком улучшений, которые вы планируете — это покажет стремление учиться и улучшать код.


Удачи на интервью — этот проект хорошо подходит как демонстрация практических навыков джуниора: видна способность мыслить структурно, писать тесты и строить простое UI вокруг логики.